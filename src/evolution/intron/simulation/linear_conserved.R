-- for Sporo1 whose parameter is simulated by gamma
-- distribution: alpha=1.9232631, lambda <- 0.3130604
-- This is the number of exons distribution
-- we assume this as the ancestral state
-- assume 10,000 genes in the genome

# just for example
# find false values before index
##       1          3          5         7    8      9        11   12
tf <- c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,TRUE);
csf <- 8
xx <- tf[1:csf-1]
length(xx[xx == F])


# number of False value before index P
# P is not counted
numberf <- function(TF, P) {
	tmpx <- TF[1:P-1]
	length(tmpx[tmpx == F])
}

new.consv.pos <- numeric()
for (i in 1:length(consv.pos)) {
	print(consv.pos[i])
	tf[consv.pos[i]] <- T;
	new.consv.pos <- c(new.consv.pos, consv.pos[i] - numberf(tf,consv.pos[i]))
	print(numberf(tf,consv.pos[i]))
}
new.consv.pos

# tf will be modified
# 
newconsvpos <- function(tf, oldpos) {
	newpos <- numeric()
	for (i in 1:length(oldpos)) {
		tf[oldpos[i]] <- T;
		newpos <- c(newpos, oldpos[i] - numberf(tf,oldpos[i]))
	}
	list(tf,newpos)
}


tf <- c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,TRUE);
consv.pos <- c(3,7,11)
newconsvpos(tf,consv.pos)

# return n numbers between 0 and 1
# with density f(x)=ax+b or f(x)=2(1-b)x+b
# 0<= b <= 1
dintronloss <- function(b, n) {
	U <- runif(n)
	X <- 0.5*(sqrt(b^2+4*(1-b)*U)-b)/(1-b)
	return(X)
}

### new  version that will use gmodel as input
# it preserved conserved introns 80% of the introns
# parameters: 
#  gm: input genome generated by programs stored in
#      build_gene.R
#  b:
#  nrt:
#
intron.loss2 <- function(gm, b, nrt) {
	numgene <- length(gm$reloc);
	# genes affected by RT
	# the same RT could hit the gene twice or more!
	# which eliminates its effect for subsequence encounter.
	# gi is the index of the genes
	gi <- sample(seq(1:numgene), nrt, replace=TRUE)
	# the affected relative intron location
	# simulate where 3'-5' reverse transcription stoped
	X <- dintronloss(b, nrt)
	for (i in 1:nrt) {
		pos <- gi[i]; 
		#print(paste('pos:', pos, gm$reloc[[pos]])) # debug
		if (gm$reloc[[pos]][1] > 0) { # has intron
		    # 5' relative to RT stoped position
			savedidx <- gm$reloc[[pos]] < X[i] # boolean vector
			# check any one is conserved
			if (gm$conserve[[pos]][1] > 0) { 
				tmpl <- newconsvpos(savedidx, gm$conserve[[pos]]);
				gm$conserve[[pos]] <- tmpl[[2]]; # new conserved position
				savedidx <- tmpl[[1]]; # Logical Vector
			}
			#gm$reloc[[pos]] <- tmp[savedidx] # this does not work
			res <- gm$reloc[[pos]][savedidx];
			if (length(res) == 0) { gm$reloc[[pos]] <- list(0); }
			else { gm$reloc[[pos]] <- res; }
		}
	}
	gm
}

########################################
ng <- 10000
consvfrac <- 0.3
consv.pergene <- 0.8
gmodel <- buildgene(ng,consvfrac,consv.pergene)
##### has conserved ntrons #######################


b <- 0.5
nrt <- 5000
gmnew <- gmodel
par(mfrow=c(4,4), mex=0.5)
# at certain fraction of the genes have one conserved intron
# say 10%, different organisms have different 
# values for this one

for (i in 1:8) {
#for (i in 1:32) {
#for (i in 1:64) {
#for (i in 1:96) {
#for (i in 1:199) {
	gmnew <- intron.loss2(gmnew, b, nrt);
	if (i %% 1 == 0 ) {
		h <- statgene(gmnew$reloc)
		hist(h$rel.loc, 100, main='', xlab='', ylab='', xlim=c(0,1), freq=F)
		hh <- hist(h$num.intron, 100, main='', xlab='', ylab='')
		avg.intron <- mean(h$num.intron)
		text(max(hh$breaks)*0.5, max(hh$count)*0.9, 
			labels=paste(i*nrt, "\n", sprintf("%1.2f",avg.intron)), 
			cex=0.9, adj=0)
	}
}


